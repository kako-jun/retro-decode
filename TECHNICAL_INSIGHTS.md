# RetroDecode 技術的知見集

このドキュメントは、RetroDecodeプロジェクトで得られた技術的知見を記録します。
将来のGUI開発や文書化で活用するための資料です。

## LF2フォーマット圧縮技術分析

### 元ファイルの圧縮性能（2025-07-02分析）

ToHeartの開発者が実装したLZSS圧縮は非常に高度で最適化されています：

| 項目 | 値 | 備考 |
|------|-----|------|
| 圧縮率 | 33.4% | 66.6%のサイズ削減 |
| リファレンス使用率 | 82% | ダイレクトピクセルは18%のみ |
| 平均マッチ長 | 12.3ピクセル | 最大18ピクセル |
| 最頻マッチ長 | 18ピクセル (44.2%) | 最長マッチを積極活用 |

### 技術的特徴

1. **高度なパターン認識**
   - ゲームアートワークの反復パターンを効率的に圧縮
   - 82%の操作でリングバッファ参照を使用

2. **最適化されたマッチング**
   - 最長マッチ（18ピクセル）を44.2%の頻度で使用
   - 2バイトで最大18ピクセルを表現する効率的エンコーディング

3. **LZSS実装の詳細**
   - 4KBリングバッファ（0x1000サイズ）
   - 初期化：0x20で埋め、0x0feeから開始
   - 全バイトにXORエンコーディング（0xff）
   - Y軸フリップ処理

### 現在の実装との比較

| 実装 | ファイルサイズ | 圧縮率 | 効率比 |
|------|-------------|--------|--------|
| オリジナル | 21,547B | 33.4% | 基準 |
| 現在（全ダイレクト） | 72,759B | 112.8% | **3.4〜5.8倍非効率** |

### 開発上の知見

1. **圧縮vs速度のトレードオフ**
   - 現在の全ダイレクト実装：高速・低圧縮
   - オリジナル実装：高圧縮・複雑

2. **複数の有効エンコード**
   - 同一画像データに対して複数の有効なLF2ファイルが存在可能
   - デコード結果は常に一意
   - エンコード方法により圧縮率が大幅に変化

3. **ラウンドトリップテスト重要性**
   - エンコード→デコード→エンコードサイクルでピクセル単位での完全一致確認
   - 64,525ピクセルで100%精度達成

## 今後の展開

1. **マッチング機能実装**
   - 元の圧縮率（33%）を目指す
   - 最適化アルゴリズムの研究

2. **GUI開発時の活用**
   - 圧縮率比較機能
   - 技術解説パネル
   - 性能ベンチマーク表示

## PAKアーカイブフォーマット解析

### 暗号化アルゴリズム

ToHeartとKizuatoのPAKアーカイブは独自の暗号化アルゴリズムを使用：

1. **ゲーム判定**
   - ToHeart: 0x0248 (584ファイル) または 0x03e1 (993ファイル)
   - Kizuato: 0x01fb (507ファイル)
   - ファイル数による自動判定が可能

2. **暗号化キー生成**
   ```
   キー長: 11バイト
   アルゴリズム: ファイルテーブル先頭72バイトから複雑な計算
   - key[0] = buf[11]
   - key[1] = buf[12] - 0x0a
   - key[5] = buf[38] - buf[22] + key[0]
   （全11バイトで差分と加算の組み合わせ）
   ```

3. **暗号化方式**
   - XOR類似だがより複雑（減算ベース）
   - キーによる循環暗号化（key_index % 11）
   - ファイル名、位置、サイズ、全データが暗号化

### 実装上の知見

1. **パフォーマンス最適化**
   - バルクI/O：テーブル全体を一度に読み込み
   - インプレース復号：メモリコピー最小化
   - SIMD対応可能な構造

2. **ファイル名形式**
   - 12バイト固定：`"C0101   LF2 "` → `"C0101.LF2"`
   - 8文字名 + 3文字拡張子 + パディング

## PDTフォーマット解析（Kanon）

### LZSSの特異性

PDTのLZSS実装はLF2と大きく異なる：

1. **データ形式**
   - 24ビットRGB（パレットなし）
   - 分離されたアルファマスク
   - BGR順序での格納

2. **圧縮アルゴリズムの違い**
   ```
   LF2との主要差異:
   - XOR処理なし（生データ）
   - Y-axis反転なし
   - RGB: copy_length = (word & 0x0f) + 1
   - Alpha: copy_length = (word & 0xff) + 2 （異なる計算）
   ```

3. **リングバッファ管理**
   - 4KB (0x1000) サイズは共通
   - 初期化値：0x00（LF2は0x20）
   - 位置計算の微妙な差異

### 技術的課題

1. **アルファマスク処理**
   - RGB圧縮とは独立した別LZSS
   - 異なる圧縮パラメータ
   - オフセット計算が重要

2. **メモリ効率**
   - RGB: 3バイト/ピクセル
   - Alpha: 1バイト/ピクセル  
   - LF2(256色)より4倍大容量

## LZSS共通実装パターン

### 葉鍵（Leaf/Key）共通要素

両ゲームのLZSS実装で共通する設計思想：

1. **リングバッファ仕様**
   - 4KB (0x1000) 固定サイズ
   - ビットマスクによる高速循環 (& 0x0fff)
   - メモリ効率重視の1990年代設計

2. **フラグベース制御**
   - 8ビットフラグで8操作を制御
   - MSBから処理：(flag & 0x80) → flag <<= 1
   - 統一された制御フロー

3. **パフォーマンス優先設計**
   - 固定サイズバッファによる境界チェック簡素化
   - ビット演算による高速位置計算
   - CPUキャッシュ効率を考慮した構造

### エンコード実装の課題

1. **往復テスト結果**
   - LF2: 100%ピクセル精度達成
   - 現在の圧縮率: 237.7%（全ダイレクトモード）
   - オリジナル圧縮率: 33.4%（高度マッチング）

2. **実装すべき最適化**
   - 最長マッチング探索（18ピクセル上限）
   - パターン認識による効率化
   - リングバッファ最適配置

## デバッグ・テスト手法

### 段階的検証アプローチ

1. **合成テストファイル**
   ```
   4x4ピクセル → 16x16 → 実ファイル
   簡単なパターンから複雑な画像へ段階的拡張
   ```

2. **往復テスト**
   ```
   オリジナル → デコード → エンコード → 比較
   バイト単位とピクセル単位の両方で検証
   ```

3. **圧縮率分析**
   ```
   元ファイル解析によるマッチング戦略理解
   リファレンス vs ダイレクトの使い分け最適化
   ```

### 実際の発見事例

1. **フラグビット順序問題**
   - 症状：99.8%サイズ一致、0%ピクセル一致
   - 原因：`flag_byte >>= 1` vs `flag_byte |= 1 << (7 - bit)`
   - 教訓：デバッグ用4x4テストの有効性

2. **Y-axis座標変換**
   - LF2のみ：デコード時にY軸反転
   - エンコード時：逆変換が必要
   - PDT：座標変換なし

## アーキテクチャ設計知見

### 多言語・多エンジン設計

RetroDecodeは教育的比較のための多言語サポートを実装：

1. **処理エンジン選択**
   ```bash
   --lang rust      # デフォルト（最高速）
   --lang python    # 教育的比較用
   --lang typescript # ブラウザ対応
   ```

2. **パフォーマンスオプション**
   ```bash
   --parallel   # 並列処理
   --gpu        # GPU加速
   --benchmark  # 性能測定
   ```

3. **教育モード**
   ```bash
   --step-by-step  # 段階的可視化
   --verbose       # 詳細ログ
   --gui           # インタラクティブ学習
   ```

### ベンチマーク設計（葉鍵ベンチ）

「葉鍵ベンチ」は異なる技術制約での性能比較システム：

1. **比較軸**
   - 言語： Rust vs Python vs TypeScript
   - 最適化： SIMD vs 通常実装
   - 並列性： シングル vs マルチスレッド
   - メモリ： 制限あり vs 制限なし

2. **制約オプション（計画中）**
   ```bash
   --unsafe         # Rust unsafeポインタ最適化
   --no-bulk-io     # 1バイト読み込み強制
   --memory-limit   # メモリ上限指定
   --no-cache       # キャッシュ無効化
   ```

### CLI設計原則

1. **ユーザビリティ**
   - 引数なし = ヘルプ表示
   - 大文字小文字区別なし拡張子
   - 直感的オプション名

2. **拡張性**
   - フォーマット自動判定
   - 出力形式選択（BMP/PNG/RAW/RGBA）
   - バッチ処理サポート

## テストアセット戦略

### 著作権回避設計

1. **合成テストファイル**
   - 4x4 → 16x16 → 256x256 段階的拡張
   - パターン、透過、パレット境界テスト
   - コミット可能（著作権フリー）

2. **テスト生成システム**
   ```rust
   examples/generate_test_assets.rs
   - 透過テスト画像生成
   - パレット境界条件テスト
   - 最大色数テスト（256色）
   ```

3. **往復テスト基盤**
   ```rust
   examples/roundtrip_test.rs
   - オリジナル → デコード → エンコード → 比較
   - バイト精度とピクセル精度の両方検証
   - 64,525ピクセルで100%精度達成実績
   ```

### 実装完成度トラッキング

現在の実装マトリックス：

| フォーマット | デコード | エンコード | 往復テスト | 圧縮最適化 |
|-------------|----------|-----------|----------|------------|
| PAK         | ✅ 完了   | N/A       | N/A      | N/A        |
| LF2         | ✅ 完了   | ✅ 完了    | ✅ 100%   | ❌ 未実装   |
| PDT         | ✅ 完了   | ❌ 未実装  | ❌ 未実装 | N/A        |
| G00         | ⚠️ 基本のみ | ❌ 未実装  | ❌ 未実装 | N/A        |

## 将来のGUI機能設計根拠

技術的知見を活用したGUI機能設計：

1. **圧縮可視化パネル**
   - オリジナル33.4% vs 現在237.7%の比較表示
   - マッチング vs ダイレクトの可視化
   - リアルタイム圧縮率計算

2. **段階的デコード表示**
   - フラグバイト処理の可視化
   - リングバッファ状態表示
   - ピクセル単位進行状況

3. **フォーマット比較機能**
   - LF2 vs PDT LZSS実装差異
   - 暗号化アルゴリズム解説
   - 歴史的文脈説明

4. **教育的ベンチマーク**
   - 言語間性能比較グラフ
   - 最適化効果の定量化
   - 1990年代制約シミュレーション

---
*最終更新: 2025-07-02*